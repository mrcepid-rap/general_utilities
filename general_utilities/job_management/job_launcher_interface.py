import math
import os
from abc import ABC, abstractmethod
from typing import Iterator

from general_utilities.mrc_logger import MRCLogger


class JobLauncherInterface(ABC):
    """
    Interface class for launching jobs using different backends.

    This class should be implemented by any job launcher utility.

    It provides methods to launch jobs, submit and monitor them, and retrieve outputs.
    :param incrementor: The incrementor for job submission, default is 500.
    :param threads: The number of threads to use for local execution, default is None.
    :param error_message: Custom error message to display in case of job submission failure.
    :raises ValueError: If the number of threads is less than 1.
    :raises RuntimeError: If an unsupported platform is detected.
    """

    def __init__(self, incrementor: int = 500, threads: int = None, error_message="An error occurred"):

        self._logger = MRCLogger(__name__).get_logger()

        self._threads = self._get_threads(threads)
        self._incrementor = incrementor
        self._error_message = error_message

        self._num_completed_jobs = 0
        self._num_jobs = 0
        self._output_array = []

    def _get_threads(self, requested_threads: int) -> int:
        """
        Get the number of threads to use for job execution.
        :param requested_threads: The number of threads requested by the user.
        :return: The number of threads to use for job execution.
        """
        threads = requested_threads if requested_threads else os.cpu_count()
        if threads is None or threads < 1:
            self._logger.error('Not enough threads on machine to complete task. Number of threads on this machine '
                               f'({threads}) is less than 1.')
        return threads

    def _print_status(self) -> None:
        """
        Print a time-stamped log of jobs waiting in the queue to be submitted and currently running.
        This method is called every time a job is completed to provide feedback on the job status.
        :return: None
        """
        if math.remainder(self._num_completed_jobs, self._incrementor) == 0 or \
                self._num_completed_jobs == self._num_jobs:
            self._logger.info(
                f'{"Total number of jobs finished":{50}}: {self._num_completed_jobs} / {self._num_jobs} '
                f'({((self._num_completed_jobs / self._num_jobs) * 100):0.2f}%)'
            )
            self._logger.info(f'{"Jobs currently running":{65}}: {self._num_jobs} / {self._num_completed_jobs}')

    @abstractmethod
    def launch_job(self, function, inputs: dict, outputs: list = None, name: str = None,
                   instance_type: str = None) -> None:
        """
        Queue a subjob with the given parameters.
        :param function: The function to execute as a subjob.
        :param inputs: A dictionary of input parameters for the job.
        :param outputs: A list of output files to be generated by the job (optional).
        :param name: The name of the job (optional).
        :param instance_type: The type of instance to use for the job (optional).
        :return: None
        """
        pass

    @abstractmethod
    def submit_and_monitor(self) -> None:
        """
        Submit the queued jobs and monitor their execution.
        :return: None
        """
        pass

    @abstractmethod
    def get_outputs(self) -> Iterator:
        """
        Retrieve the outputs of the completed jobs.
        :return: A list of output files generated by the jobs.
        """
        pass
