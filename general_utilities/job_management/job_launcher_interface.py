import math
import os
from abc import ABC, abstractmethod
from typing import Iterator, Any

from general_utilities.job_management.subjob_utility import SubjobUtility
from general_utilities.job_management.thread_utility import ThreadUtility
from general_utilities.mrc_logger import MRCLogger
from general_utilities.platform_utils.platform_factory import Platform, PlatformFactory


class JobLauncherInterface(ABC):
    """
    Interface class for launching jobs using different backends.

    This class should be implemented by any job launcher utility.

    It provides methods to launch jobs, submit and monitor them, and retrieve outputs.
    :param incrementor: The incrementor for job submission, default is 500.
    :param threads: The number of threads to use for local execution, default is None.
    :param error_message: Custom error message to display in case of job submission failure.
    :raises ValueError: If the number of threads is less than 1.
    :raises RuntimeError: If an unsupported platform is detected.
    """

    def __init__(self, incrementor: int = 500, threads: int = None, concurrent_job_limit: int = 100, **kwargs):

        self._logger = MRCLogger(__name__).get_logger()

        self._threads = self._get_threads(threads)
        self._incrementor = incrementor

        self._concurrent_job_limit = concurrent_job_limit

        self._num_completed_jobs = 0
        self._total_jobs = 0
        self._output_array = []

        self._queue_closed = False  # A flag to make sure we don't submit jobs to a closed executor

    def _get_threads(self, requested_threads: int) -> int:
        """
        Get the number of threads to use for job execution.
        :param requested_threads: The number of threads requested by the user.
        :return: The number of threads to use for job execution.
        """
        threads = requested_threads if requested_threads else os.cpu_count()
        if threads is None or threads < 1:
            self._logger.error('Not enough threads on machine to complete task. Number of threads on this machine '
                               f'({threads}) is less than 1.')
        return threads

    def _print_status(self) -> None:
        """
        Print a time-stamped log of jobs waiting in the queue to be submitted and currently running.
        This method is called every time a job is completed to provide feedback on the job status.
        :return: None
        """
        if math.remainder(self._num_completed_jobs, self._incrementor) == 0 or \
                self._num_completed_jobs == self._total_jobs:
            self._logger.info(
                f'{"Total number of jobs finished":{50}}: {self._num_completed_jobs} / {self._total_jobs} '
                f'({((self._num_completed_jobs / self._total_jobs) * 100):0.2f}%)'
            )
            self._logger.info(f'{"Jobs currently running":{65}}: {self._total_jobs} / {self._num_completed_jobs}')

    @abstractmethod
    def __iter__(self) -> Iterator:
        """
        Make the job launcher iterable.
        This method should return an iterator over the launched jobs.
        :return: An iterator over the launched jobs.
        """
        pass

    @abstractmethod
    def __len__(self) -> int:
        """
        Get the number of jobs in the queue.
        :return: The total number of jobs in the queue.
        """
        pass

    @abstractmethod
    def __next__(self) -> Any:
        """
        Return the next result/output in iteration.
        :return: The next job in the queue.
        """
        pass

    @abstractmethod
    def launch_job(self, function, inputs: dict, outputs: list = None, name: str = None,
                   instance_type: str = None) -> None:
        """
        Queue a subjob with the given parameters.
        :param function: The function to execute as a subjob.
        :param inputs: A dictionary of input parameters for the job.
        :param outputs: A list of output files to be generated by the job (optional).
        :param name: The name of the job (optional).
        :param instance_type: The type of instance to use for the job (optional).
        :return: None
        """
        pass

    @abstractmethod
    def submit_and_monitor(self) -> None:
        """
        Submit the queued jobs and monitor their execution.
        :return: None
        """
        pass


def joblauncher_factory(concurrent_job_limit: int = 100, incrementor: int = 500,
                        download_on_complete: bool = False, thread_factor: int = 1,
                        threads: int = None, **kwargs) -> JobLauncherInterface:
    """
    Job launcher that uses either SubjobUtility for DX or ThreadUtility for local execution.
    GCP is not supported in this implementation.

    This class detects the platform and initializes the appropriate backend utility for job management.
    It provides methods to launch jobs, submit and monitor them, and retrieve outputs.

    :param concurrent_job_limit: The maximum number of concurrent jobs to run, default is 100.
    :param retries: The number of retries for job submission, default is 1.
    :param incrementor: The incrementor for job submission, default is 500.
    :param download_on_complete: Whether to download outputs on job completion, default is False.
    :param thread_factor: The factor to multiply the number of threads by for local execution, default is 1.
    :param threads: The number of threads to use for local execution, default is None.
    :raises RuntimeError: If an unsupported platform is detected (GCP not currently implemented).
    """

    platform = PlatformFactory().get_platform()

    if platform == Platform.DX:
        backend = SubjobUtility(concurrent_job_limit=concurrent_job_limit,
                                incrementor=incrementor,
                                download_on_complete=download_on_complete,
                                **kwargs)
    elif platform == Platform.LOCAL:
        backend = ThreadUtility(threads=threads,
                                incrementor=incrementor,
                                thread_factor=thread_factor)
    else:
        raise RuntimeError("Unsupported platform")
    return backend
