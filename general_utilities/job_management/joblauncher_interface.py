import math
from abc import ABC, abstractmethod
from typing import Iterator, Any, Optional, Dict, List

from general_utilities.mrc_logger import MRCLogger


class JobLauncherInterface(ABC):
    """
    Interface class for launching jobs using different backends.

    This class should be implemented by any job launcher utility.

    It provides methods to launch jobs, submit and monitor them, and retrieve outputs.
    :param incrementor: The incrementor for job submission, default is 500.
    :param threads: The number of threads to use for local execution, default is None.
    :param error_message: Custom error message to display in case of job submission failure.
    :raises ValueError: If the number of threads is less than 1.
    :raises RuntimeError: If an unsupported platform is detected.
    """

    def __init__(self, incrementor: int = 500, concurrent_job_limit: int = 100):

        self._logger = MRCLogger(__name__).get_logger()

        self._incrementor = incrementor

        self._concurrent_job_limit = concurrent_job_limit

        self._num_completed_jobs = 0
        self._total_jobs = 0
        self._output_array = []

        self._queue_closed = False  # A flag to make sure we don't submit jobs to a closed executor

    def _print_status(self) -> None:
        """
        Print a time-stamped log of jobs waiting in the queue to be submitted and currently running.
        This method is called every time a job is completed to provide feedback on the job status.
        :return: None
        """
        if math.remainder(self._num_completed_jobs, self._incrementor) == 0 or \
                self._num_completed_jobs == self._total_jobs:
            self._logger.info(
                f'{"Total number of jobs finished":{50}}: {self._num_completed_jobs} / {self._total_jobs} '
                f'({((self._num_completed_jobs / self._total_jobs) * 100):0.2f}%)'
            )
            self._logger.info(f'{"Jobs currently running":{65}}: {self._total_jobs} / {self._num_completed_jobs}')

    @abstractmethod
    def __iter__(self) -> Iterator:
        """
        Make the job launcher iterable.
        This method should return an iterator over the launched jobs.
        :return: An iterator over the launched jobs.
        """
        pass

    @abstractmethod
    def __len__(self) -> int:
        """
        Get the number of jobs in the queue.
        :return: The total number of jobs in the queue.
        """
        pass

    @abstractmethod
    def __next__(self) -> Any:
        """
        Return the next result/output in iteration.
        :return: The next job in the queue.
        """
        pass

    @abstractmethod
    def launch_job(self, function, inputs: Optional[Dict[str, Any]] = None,
                   outputs: Optional[List] = None, name: Optional[str] = None,
                   instance_type: Optional[str] = None, **kwargs) -> None:
        """
        Queue a subjob with the given parameters.
        :param function: The function to execute as a subjob.
        :param inputs: A dictionary of input parameters for the job.
        :param outputs: A list of output files to be generated by the job (optional).
        :param name: The name of the job (optional).
        :param instance_type: The type of instance to use for the job (optional).
        :return: None
        """
        pass

    @abstractmethod
    def submit_and_monitor(self) -> None:
        """
        Submit the queued jobs and monitor their execution.
        :return: None
        """
        pass
