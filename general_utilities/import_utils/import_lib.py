import csv
import os
import re
import tarfile
from enum import Enum, auto
from pathlib import Path
from typing import Dict, TypedDict, Optional, Union, Any, List, Tuple, Set

import dxpy
from general_utilities.import_utils.file_handlers.input_file_handler import InputFileHandler
from general_utilities.mrc_logger import MRCLogger

LOGGER = MRCLogger().get_logger()


class BGENInformation(TypedDict):
    """A TypedDict holding information about a chromosome's available genetic data

    :cvar bgen: A .bgen file containing genetic data.
    :cvar index: A .bgen.bgi index file for :cvar bgen:
    :cvar sample: A .sample file containing sample information for :cvar bgen:
    :cvar vep: The per-variant annotation for all or a filtered subset (typically on INFO / MAF) variants in :cvar bgen:
    :cvar vepidx: The index for the per-variant VEP annotation
    """
    bgen: InputFileHandler
    index: InputFileHandler
    sample: InputFileHandler
    vep: Optional[InputFileHandler]
    vepidx: Optional[InputFileHandler]


def download_bgen_file(chrom_bgen_index: BGENInformation) -> None:
    """Download and process a bgen file when requested

    :param chrom_bgen_index: An object of :func:`BGENInformation` containing :func:`InputFileHandler` class for the bgen
    :return: None
    """

    # First we have to download the actual data
    chrom_bgen_index['index'].get_file_handle()
    chrom_bgen_index['sample'].get_file_handle()
    chrom_bgen_index['bgen'].get_file_handle()
    # Now we need to download the VEP file if it exists
    if chrom_bgen_index['vep'] is not None:
        chrom_bgen_index['vep'].get_file_handle()
        chrom_bgen_index['vepidx'].get_file_handle()


def ingest_wes_bgen(bgen_index: Union[InputFileHandler, dict]) -> Dict[str, BGENInformation]:
    """Download the entire filtered WES variant data set in bgen format

    The format of this file must be like the following (all spaces are tabs):

    chrom   vep_dxid   bgen_dxid    bgen_index_dxid   sample_dxid
    1    file-1234567890ABCDEFGH   file-0987654321ABCDEFGH   file-1234567890HGFEDCBA   file-0987654321HGFEDCBA

    :param bgen_index: A DNANexus file reference (file-12345) pointing to a TSV-format 'dictionary' of file paths
    :return: A Dict with keys of chromosomes and values of the BGENInformation typeddict
    """

    bgen_index = bgen_index.get_file_handle()

    with Path(bgen_index).open('r') as bgen_index:
        bgen_index_csv = csv.DictReader(bgen_index, delimiter='\t')
        bgen_dict: Dict[str, BGENInformation] = dict()
        for line in bgen_index_csv:
            bgen_info: BGENInformation = {
                'index': InputFileHandler(line['bgen_index_dxid']),
                'sample': InputFileHandler(line['sample_dxid']),
                'bgen': InputFileHandler(line['bgen_dxid']),
                'vep': InputFileHandler(line['vep_dxid']),
                'vepidx': InputFileHandler(line['vep_index_dxid'])
            }
            bgen_dict[line['chrom']] = bgen_info

    return bgen_dict


class TarballType(Enum):

    """An Enum to represent the type of tarball being processed

    The value of the enum is the dummy gene ID expected by downstream linear models.
    """
    SNP = 'ENST00000000000'
    GENE = 'ENST99999999999'
    GENOMEWIDE = None


def ingest_tarballs(association_tarballs: Union[InputFileHandler, List[InputFileHandler]]) -> Tuple[TarballType, List[str]]:
    """Download the collapsed gene masks generated by mrcepid-collapsevariants

    This method will download either a single tarfile OR a list file of multiple tarfiles into this AWS instance. The
    files downloaded here MUST have been generated by the applet mrcepid-collapsevariants.

    :param association_tarballs: A single InputFileHandler class or a list of InputFileHandler classes
        pointing to tar.gz file(s) generated by mrcepid-collapsevariants.
    :return: A Tuple consisting of is_snp, is_gene, and named_prefix's found in the provided file
    """
    is_snp_tar = False
    is_gene_tar = False
    is_burden_tar = True # We assume a burden tarball unless we find a SNP or GENE tarball
    tarball_prefixes = []

    # First create a list of DNANexus fileIDs to process
    tar_files = []

    # association_tarballs likely to be a single tarball:
    if '.tar.gz' in str(association_tarballs.get_input_str()):
        tar_files.append(association_tarballs)
    if isinstance(association_tarballs, list):
        # If it's a list, iterate over it
        for tarball in association_tarballs:
            unzipped = tarball.get_file_handle()
            tar_files.append(unzipped)
    elif isinstance(association_tarballs, InputFileHandler):
        # If it's a single InputFileHandler instance, append it directly
        tar_files = [association_tarballs.get_file_handle()]
    else:
        raise TypeError("association_tarballs must be an InputFileHandler or a list of InputFileHandler instances")

    # Now process them in order
    for tar_file in tar_files:
        if tarfile.is_tarfile(tar_file):
            tarball_prefix = tar_file.name.replace('.tar.gz', '')
            tarball_prefixes.append(tarball_prefix)
            tar = tarfile.open(tar_file, 'r:gz')
            tar.extractall()

            # Construct regex dynamically from tarball_prefixes
            prefix_pattern = "|".join(
                re.escape(prefix) for prefix in tarball_prefixes)  # Escape in case of special characters
            pattern = rf'^(?:{prefix_pattern})\.([^.]+?)\.(?:BOLT|REGENIE|SAIGE|STAAR)'
            # Extract matches
            matches = set()
            for name in tar.getnames():
                match = re.search(pattern, name)
                if match:
                    extracted_value = match.group(1)  # Extract the second part after the prefix
                    if extracted_value not in {"SNP", "GENE"}:  # Remove SNP and GENE
                        matches.add(extracted_value)

            if Path(f'{tarball_prefix}.SNP.BOLT.bgen').exists():
                is_snp_tar = True
                is_burden_tar = False
            elif Path(f'{tarball_prefix}.GENE.BOLT.bgen').exists():
                is_gene_tar = True
                is_burden_tar = False

        else:
            raise dxpy.AppError(f'Provided association tarball ({tar_file}) '
                                f'is not a tar.gz file')


    if 0 < sum([is_burden_tar, is_gene_tar, is_snp_tar]) < 2:
        if is_snp_tar:
            tarball_type = TarballType.SNP
        elif is_gene_tar:
            tarball_type = TarballType.GENE
        elif is_burden_tar:
            tarball_type = TarballType.GENOMEWIDE
        else:
            raise ValueError('Unexpected tarball type encountered')
    else:
        raise IOError('Input tar files cannot be a mix of SNP, GENE, and / or Burden masks')

    return tarball_type, tarball_prefixes


def process_regenie_step_one(regenie_run_location: InputFileHandler) -> bool:
    """A simple method to find, and if found, download a previously run REGENIE analysis.

    :param regenie_run_location: A possible InputFileHandler class reference to a previous regenie run
    :return: A boolean indicating whether step one regenie data was found
    """

    if regenie_run_location is None:
        return False
    else:
        tarball_path = regenie_run_location.get_file_handle()
        if tarfile.is_tarfile(tarball_path):
            tar = tarfile.open(tarball_path, 'r:gz')
            tar.extractall()
        return True
