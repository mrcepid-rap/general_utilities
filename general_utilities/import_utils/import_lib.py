import csv
import re
import dxpy
import tarfile
from enum import Enum
from pathlib import Path
from typing import Dict, TypedDict, Optional, Union, List, Tuple

from association_resources import replace_multi_suffix
from general_utilities.mrc_logger import MRCLogger
from general_utilities.import_utils.file_handlers.input_file_handler import InputFileHandler

LOGGER = MRCLogger().get_logger()


class BGENInformation(TypedDict):
    """A TypedDict holding information about a chromosome's available genetic data

    :cvar bgen: A .bgen file containing genetic data.
    :cvar index: A .bgen.bgi index file for :cvar bgen:
    :cvar sample: A .sample file containing sample information for :cvar bgen:
    :cvar vep: The per-variant annotation for all or a filtered subset (typically on INFO / MAF) variants in :cvar bgen:
    :cvar vepidx: The index for the per-variant VEP annotation
    """
    bgen: InputFileHandler
    index: InputFileHandler
    sample: InputFileHandler
    vep: Optional[InputFileHandler]
    vepidx: Optional[InputFileHandler]


def download_bgen_file(chrom_bgen_index: BGENInformation) -> Tuple[Path, Path, Path, Path, Path]:
    """Download and process a bgen file when requested

    :param chrom_bgen_index: An object of :func:`BGENInformation` containing :func:`InputFileHandler` class for the bgen
    :return: None
    """

    # Download the actual data
    bgen_index = chrom_bgen_index['index'].get_file_handle()
    bgen_sample = chrom_bgen_index['sample'].get_file_handle()
    bgen = chrom_bgen_index['bgen'].get_file_handle()
    # Now we need to download the VEP file if it exists
    if chrom_bgen_index['vep'] is not None:
        vep = chrom_bgen_index['vep'].get_file_handle()
        vep_index = chrom_bgen_index['vepidx'].get_file_handle()
    else:
        vep = None
        vep_index = None

    # Return the paths to the downloaded files
    return bgen, bgen_index, bgen_sample, vep, vep_index


def ingest_wes_bgen(bgen_index: Union[InputFileHandler, dict]) -> Dict[str, BGENInformation]:
    """Download the entire filtered WES variant data set in bgen format

    The format of this file must be like the following (all spaces are tabs):

    chrom   vep_dxid   bgen_dxid    bgen_index_dxid   sample_dxid
    1    file-1234567890ABCDEFGH   file-0987654321ABCDEFGH   file-1234567890HGFEDCBA   file-0987654321HGFEDCBA

    :param bgen_index: A DNANexus file reference (file-12345) pointing to a TSV-format 'dictionary' of file paths
    :return: A Dict with keys of chromosomes and values of the BGENInformation typeddict
    """

    bgen_index = bgen_index.get_file_handle()

    with Path(bgen_index).open('r') as bgen_index:
        bgen_index_csv = csv.DictReader(bgen_index, delimiter='\t')
        bgen_dict: Dict[str, BGENInformation] = dict()
        for line in bgen_index_csv:
            bgen_info: BGENInformation = {
                'index': InputFileHandler(line['bgen_index_dxid']),
                'sample': InputFileHandler(line['sample_dxid']),
                'bgen': InputFileHandler(line['bgen_dxid']),
                'vep': InputFileHandler(line['vep_dxid']),
                'vepidx': InputFileHandler(line['vep_index_dxid'])
            }
            bgen_dict[line['chrom']] = bgen_info

    return bgen_dict


class TarballType(Enum):
    """An Enum to represent the type of tarball being processed

    The value of the enum is the dummy gene ID expected by downstream linear models.
    """
    SNP = 'ENST00000000000'
    GENE = 'ENST99999999999'
    GENOMEWIDE = None


def ingest_tarballs(association_tarballs: Union[InputFileHandler, List[InputFileHandler]]) -> Tuple[TarballType, List[Path]]:
    """Download the collapsed gene masks generated by mrcepid-collapsevariants

    This method will download either a single tarfile OR a list file of multiple tarfiles into this AWS instance. The
    files downloaded here MUST have been generated by the applet mrcepid-collapsevariants.

    :param association_tarballs: A single InputFileHandler class or a list of InputFileHandler classes
        pointing to tar.gz file(s) generated by mrcepid-collapsevariants.
    :return: A Tuple consisting of is_snp, is_gene, and named_prefix's found in the provided file
    """
    is_snp_tar = False
    is_gene_tar = False
    is_burden_tar = True  # We assume a burden tarball unless we find a SNP or GENE tarball
    tarball_prefixes = []

    # First create a list of DNANexus fileIDs to process
    tar_files = []

    try:
        # association_tarballs likely to be a single tarball or a txt file with links:
        input_str = str(association_tarballs.get_input_str())
        if re.match('file-\\w{24}', input_str):
            input_str = InputFileHandler(input_str, download_now=True).get_file_handle()

        # if the input is a tar.gz file, append it directly
        if tarfile.is_tarfile(input_str):
            tar_files.append(association_tarballs.get_file_handle())
        # When association_tarballs is a .txt file, read file IDs and process them
        else:
            # input must be a text file if not a tar.gz or a list - if not true, the user should investigate what they passed
            with input_str.open('r') as f:
                for line in f:
                    file_path = InputFileHandler(line).get_file_handle()
                    tar_files.append(file_path)
    except Exception as e:
        LOGGER.error(f"Error processing association_tarballs: {e}, please check the input provided.")
        raise

    # Now process them in order
    for tar_file in tar_files:
        if tarfile.is_tarfile(tar_file):
            tarball_prefix = replace_multi_suffix(tar_file, '')
            if not tarball_prefix.with_suffix('.tar.gz').exists():
                # The only reason I do this is I am paranoid that users will drop random '.' into their filenames and
                # break replace_multi_suffix()
                raise ValueError('Tarball prefix generation failed; unexpected file suffixes. Do you have extra periods '
                                 'in your filenames?')

            tarball_prefixes.append(tarball_prefix)
            tar = tarfile.open(tar_file, 'r:gz')
            tar.extractall()

            if tarball_prefix.with_suffix('.SNP.BOLT.bgen').exists():
                is_snp_tar = True
                is_burden_tar = False
            elif tarball_prefix.with_suffix('.GENE.BOLT.bgen').exists():
                is_gene_tar = True
                is_burden_tar = False

        else:
            raise dxpy.AppError(f'Provided association tarball ({tar_file}) '
                                f'is not a tar.gz file')

    if 0 < sum([is_burden_tar, is_gene_tar, is_snp_tar]) < 2:
        if is_snp_tar:
            tarball_type = TarballType.SNP
        elif is_gene_tar:
            tarball_type = TarballType.GENE
        elif is_burden_tar:
            tarball_type = TarballType.GENOMEWIDE
        else:
            raise ValueError('Unexpected tarball type encountered')
    else:
        raise IOError('Input tar files cannot be a mix of SNP, GENE, and / or Burden masks')

    return tarball_type, tarball_prefixes


def process_regenie_step_one(regenie_run_location: InputFileHandler) -> bool:
    """A simple method to find, and if found, download a previously run REGENIE analysis.

    :param regenie_run_location: A possible InputFileHandler class reference to a previous regenie run
    :return: A boolean indicating whether step one regenie data was found
    """

    if regenie_run_location is None:
        return False
    else:
        tarball_path = regenie_run_location.get_file_handle()
        if tarfile.is_tarfile(tarball_path):
            tar = tarfile.open(tarball_path, 'r:gz')
            tar.extractall()
        return True